{
  "lmps": {
    "fgen": {
      "prompt_text": "import numpy as np\nfrom shapely.geometry import *\nfrom shapely.affinity import *\n\nfrom env_utils import get_obj_pos, get_obj_names\nfrom ctrl_utils import put_first_on_second\n\n# define function: total = get_total(xs=numbers).\ndef get_total(xs):\n    return np.sum(xs)\n\n# define function: y = eval_line(x, slope, y_intercept=0).\ndef eval_line(x, slope, y_intercept):\n    return x * slope + y_intercept\n\n# define function: pt = get_pt_to_the_left(pt, dist).\ndef get_pt_to_the_left(pt, dist):\n    return pt + [-dist, 0]\n\n# define function: pt = get_pt_to_the_top(pt, dist).\ndef get_pt_to_the_top(pt, dist):\n    return pt + [0, dist]\n\n# define function line = make_line_by_length(length=x).\ndef make_line_by_length(length):\n  line = LineString([[0, 0], [length, 0]])\n  return line\n\n# define function: line = make_vertical_line_by_length(length=x).\ndef make_vertical_line_by_length(length):\n  line = make_line_by_length(length)\n  vertical_line = rotate(line, 90)\n  return vertical_line\n\n# define function: pt = interpolate_line(line, t=0.5).\ndef interpolate_line(line, t):\n  pt = line.interpolate(t, normalized=True)\n  return np.array(pt.coords[0])\n\n# example: scale a line by 2.\nline = make_line_by_length(1)\nnew_shape = scale(line, xfact=2, yfact=2)\n\n# example: put object1 on top of object0.\nput_first_on_second('object1', 'object0')\n\n# example: get the position of the first object.\nobj_names = get_obj_names()\npos_2d = get_obj_pos(obj_names[0])",
      "engine": "gpt-4",
      "max_tokens": 512,
      "temperature": 0,
      "query_prefix": "# ",
      "query_suffix": ".",
      "stop": [
        "#"
      ],
      "maintain_session": false,
      "debug_mode": false,
      "include_context": true,
      "has_return": true,
      "return_val_name": "new_shape_pts"
    },
    "parse_obj_name": {
      "prompt_text": "import numpy as np\nfrom env_utils import get_obj_pos, parse_position\nfrom utils import get_obj_positions_np\n\nobjects = ['blue block', 'cyan block', 'purple bowl', 'gray bowl', 'brown bowl', 'pink block', 'purple block']\n# the block closest to the purple bowl.\nblock_names = ['blue block', 'cyan block', 'purple block']\nblock_positions = get_obj_positions_np(block_names)\nclosest_block_idx = get_closest_idx(points=block_positions, point=get_obj_pos('purple bowl'))\nclosest_block_name = block_names[closest_block_idx]\nret_val = closest_block_name\nobjects = ['brown bowl', 'banana', 'brown block', 'apple', 'blue bowl', 'blue block']\n# the blocks.\nret_val = ['brown block', 'blue block']\nobjects = ['brown bowl', 'banana', 'brown block', 'apple', 'blue bowl', 'blue block']\n# the brown objects.\nret_val = ['brown bowl', 'brown block']\nobjects = ['brown bowl', 'banana', 'brown block', 'apple', 'blue bowl', 'blue block']\n# a fruit that's not the apple\nfruit_names = ['banana', 'apple']\nfor fruit_name in fruit_names:\n    if fruit_name != 'apple':\n        ret_val = fruit_name\nobjects = ['blue block', 'cyan block', 'purple bowl', 'brown bowl', 'purple block']\n# blocks above the brown bowl.\nblock_names = ['blue block', 'cyan block', 'purple block']\nbrown_bowl_pos = get_obj_pos('brown bowl')\nuse_block_names = []\nfor block_name in block_names:\n    if get_obj_pos(block_name)[1] > brown_bowl_pos[1]:\n        use_block_names.append(block_name)\nret_val = use_block_names\nobjects = ['blue block', 'cyan block', 'purple bowl', 'brown bowl', 'purple block']\n# the blue block.\nret_val = 'blue block'\nobjects = ['blue block', 'cyan block', 'purple bowl', 'brown bowl', 'purple block']\n# the block closest to the bottom right corner.\ncorner_pos = parse_position('bottom right corner')\nblock_names = ['blue block', 'cyan block', 'purple block']\nblock_positions = get_obj_positions_np(block_names)\nclosest_block_idx = get_closest_idx(points=block_positions, point=corner_pos)\nclosest_block_name = block_names[closest_block_idx]\nret_val = closest_block_name\nobjects = ['brown bowl', 'green block', 'brown block', 'green bowl', 'blue bowl', 'blue block']\n# the left most block.\nblock_names = ['green block', 'brown block', 'blue block']\nblock_positions = get_obj_positions_np(block_names)\nleft_block_idx = np.argsort(block_positions[:, 0])[0]\nleft_block_name = block_names[left_block_idx]\nret_val = left_block_name\nobjects = ['brown bowl', 'green block', 'brown block', 'green bowl', 'blue bowl', 'blue block']\n# the bowl on near the top.\nbowl_names = ['brown bowl', 'green bowl', 'blue bowl']\nbowl_positions = get_obj_positions_np(bowl_names)\ntop_bowl_idx = np.argsort(block_positions[:, 1])[-1]\ntop_bowl_name = bowl_names[top_bowl_idx]\nret_val = top_bowl_name\nobjects = ['yellow bowl', 'purple block', 'yellow block', 'purple bowl', 'pink bowl', 'pink block']\n# the third bowl from the right.\nbowl_names = ['yellow bowl', 'purple bowl', 'pink bowl']\nbowl_positions = get_obj_positions_np(bowl_names)\nbowl_idx = np.argsort(block_positions[:, 0])[-3]\nbowl_name = bowl_names[bowl_idx]\nret_val = bowl_name",
      "engine": "gpt-4",
      "max_tokens": 512,
      "temperature": 0,
      "query_prefix": "# ",
      "query_suffix": ".",
      "stop": [
        "#"
      ],
      "maintain_session": false,
      "debug_mode": false,
      "include_context": true,
      "has_return": true,
      "return_val_name": "new_shape_pts"
    },
    "parse_position": {
      "prompt_text": "import numpy as np\nfrom shapely.geometry import *\nfrom shapely.affinity import *\nfrom env_utils import denormalize_xy, parse_obj_name, get_obj_names, get_obj_pos\n\n# a 30cm horizontal line in the middle with 3 points.\nmiddle_pos = denormalize_xy([0.5, 0.5]) \nstart_pos = middle_pos + [-0.3/2, 0]\nend_pos = middle_pos + [0.3/2, 0]\nline = make_line(start=start_pos, end=end_pos)\npoints = interpolate_pts_on_line(line=line, n=3)\nret_val = points\n# a 20cm vertical line near the right with 4 points.\nmiddle_pos = denormalize_xy([1, 0.5]) \nstart_pos = middle_pos + [0, -0.2/2]\nend_pos = middle_pos + [0, 0.2/2]\nline = make_line(start=start_pos, end=end_pos)\npoints = interpolate_pts_on_line(line=line, n=4)\nret_val = points\n# a diagonal line from the top left to the bottom right corner with 5 points.\ntop_left_corner = denormalize_xy([0, 1])\nbottom_right_corner = denormalize_xy([1, 0])\nline = make_line(start=top_left_corner, end=bottom_right_corner)\npoints = interpolate_pts_on_line(line=line, n=5)\nret_val = points\n# a triangle with size 10cm with 3 points.\npolygon = make_triangle(size=0.1, center=denormalize_xy([0.5, 0.5]))\npoints = get_points_from_polygon(polygon)\nret_val = points\n# the corner closest to the sun colored block.\nblock_name = parse_obj_name('the sun colored block', f'objects = {get_obj_names()}')\ncorner_positions = np.array([denormalize_xy(pos) for pos in [[0, 0], [0, 1], [1, 1], [1, 0]]])\nclosest_corner_pos = get_closest_point(points=corner_positions, point=get_obj_pos(block_name))\nret_val = closest_corner_pos\n# the side farthest from the right most bowl.\nbowl_name = parse_obj_name('the right most bowl', f'objects = {get_obj_names()}')\nside_positions = np.array([denormalize_xy(pos) for pos in [[0.5, 0], [0.5, 1], [1, 0.5], [0, 0.5]]])\nfarthest_side_pos = get_farthest_point(points=side_positions, point=get_obj_pos(bowl_name))\nret_val = farthest_side_pos\n# a point above the third block from the bottom.\nblock_name = parse_obj_name('the third block from the bottom', f'objects = {get_obj_names()}')\nret_val = get_obj_pos(block_name) + [0.1, 0]\n# a point 10cm left of the bowls.\nbowl_names = parse_obj_name('the bowls', f'objects = {get_obj_names()}')\nbowl_positions = get_all_object_positions_np(obj_names=bowl_names)\nleft_obj_pos = bowl_positions[np.argmin(bowl_positions[:, 0])] + [-0.1, 0]\nret_val = left_obj_pos\n# the bottom side.\nbottom_pos = denormalize_xy([0.5, 0])\nret_val = bottom_pos\n# the top corners.\ntop_left_pos = denormalize_xy([0, 1])\ntop_right_pos = denormalize_xy([1, 1])\nret_val = [top_left_pos, top_right_pos]",
      "engine": "gpt-4",
      "max_tokens": 512,
      "temperature": 0,
      "query_prefix": "# ",
      "query_suffix": ".",
      "stop": [
        "#"
      ],
      "maintain_session": false,
      "debug_mode": false,
      "include_context": true,
      "has_return": true,
      "return_val_name": "new_shape_pts"
    },
    "parse_question": {
      "prompt_text": "from utils import get_obj_pos, get_obj_names, parse_obj_name, bbox_contains_pt, is_obj_visible\n\nobjects = ['yellow bowl', 'blue block', 'yellow block', 'blue bowl', 'fruit', 'green block', 'black bowl']\n# is the blue block to the right of the yellow bowl?\nret_val = get_obj_pos('blue block')[0] > get_obj_pos('yellow bowl')[0]\nobjects = ['yellow bowl', 'blue block', 'yellow block', 'blue bowl', 'fruit', 'green block', 'black bowl']\n# how many yellow objects are there?\nyellow_object_names = parse_obj_name('the yellow objects', f'objects = {get_obj_names()}')\nret_val = len(yellow_object_names)\nobjects = ['pink block', 'green block', 'pink bowl', 'blue block', 'blue bowl', 'green bowl']\n# is the pink block on the green bowl?\nret_val = bbox_contains_pt(container_name='green bowl', obj_name='pink block')\nobjects = ['pink block', 'green block', 'pink bowl', 'blue block', 'blue bowl', 'green bowl']\n# what are the blocks left of the green bowl?\nblock_names = parse_obj_name('the blocks', f'objects = {get_obj_names()}')\ngreen_bowl_pos = get_obj_pos('green bowl')\nleft_block_names = []\nfor block_name in block_names:\n  if get_obj_pos(block_name)[0] < green_bowl_pos[0]:\n    left_block_names.append(block_name)\nret_val = left_block_names\nobjects = ['pink block', 'yellow block', 'pink bowl', 'blue block', 'blue bowl', 'yellow bowl']\n# is the sun colored block above the blue bowl?\nsun_block_name = parse_obj_name('sun colored block', f'objects = {get_obj_names()}')\nsun_block_pos = get_obj_pos(sun_block_name)\nblue_bowl_pos = get_obj_pos('blue bowl')\nret_val = sun_block_pos[1] > blue_bowl_pos[1]\nobjects = ['pink block', 'yellow block', 'pink bowl', 'blue block', 'blue bowl', 'yellow bowl']\n# is the green block below the blue bowl?\nret_val = get_obj_pos('green block')[1] < get_obj_pos('blue bowl')[1]",
      "engine": "gpt-4",
      "max_tokens": 512,
      "temperature": 0,
      "query_prefix": "# ",
      "query_suffix": ".",
      "stop": [
        "#"
      ],
      "maintain_session": false,
      "debug_mode": false,
      "include_context": true,
      "has_return": true,
      "return_val_name": "new_shape_pts"
    },
    "table_ui": {
      "prompt_text": "# Python 2D robot control script\nimport numpy as np\nfrom env_utils import put_first_on_second, get_obj_pos, get_obj_names, say, get_corner_name, get_side_name, is_obj_visible, stack_objects_in_order\nfrom plan_utils import parse_obj_name, parse_position, parse_question, transform_shape_pts\n\nobjects = ['yellow block', 'green block', 'yellow bowl', 'blue block', 'blue bowl', 'green bowl']\n# the yellow block on the yellow bowl.\nsay('Ok - putting the yellow block on the yellow bowl')\nput_first_on_second('yellow block', 'yellow bowl')\nobjects = ['yellow block', 'green block', 'yellow bowl', 'blue block', 'blue bowl', 'green bowl']\n# which block did you move.\nsay('I moved the yellow block')\nobjects = ['yellow block', 'green block', 'yellow bowl', 'blue block', 'blue bowl', 'green bowl']\n# move the green block to the top right corner.\nsay('Got it - putting the green block on the top right corner')\ncorner_pos = parse_position('top right corner')\nput_first_on_second('green block', corner_pos)\nobjects = ['yellow block', 'green block', 'yellow bowl', 'blue block', 'blue bowl', 'green bowl']\n# stack the blue bowl on the yellow bowl on the green block.\norder_bottom_to_top = ['green block', 'yellow block', 'blue bowl']\nsay(f'Sure - stacking from top to bottom: {\", \".join(order_bottom_to_top)}')\nstack_objects_in_order(object_names=order_bottom_to_top)\nobjects = ['cyan block', 'white block', 'cyan bowl', 'blue block', 'blue bowl', 'white bowl']\n# move the cyan block into its corresponding bowl.\nmatches = {'cyan block': 'cyan bowl'}\nsay('Got it - placing the cyan block on the cyan bowl')\nfor first, second in matches.items():\n  put_first_on_second(first, get_obj_pos(second))\nobjects = ['cyan block', 'white block', 'cyan bowl', 'blue block', 'blue bowl', 'white bowl']\n# make a line of blocks on the right side.\nsay('No problem! Making a line of blocks on the right side')\nblock_names = parse_obj_name('the blocks', f'objects = {get_obj_names()}')\nline_pts = parse_position(f'a 30cm vertical line on the right with {len(block_names)} points')\nfor block_name, pt in zip(block_names, line_pts):\n  put_first_on_second(block_name, pt)\nobjects = ['yellow block', 'red block', 'yellow bowl', 'gray block', 'gray bowl', 'red bowl']\n# put the small banana colored thing in between the blue bowl and green block.\nsay('Sure thing - putting the yellow block between the blue bowl and the green block')\ntarget_pos = parse_position('a point in the middle betweeen the blue bowl and the green block')\nput_first_on_second('yellow block', target_pos)\nobjects = ['yellow block', 'red block', 'yellow bowl', 'gray block', 'gray bowl', 'red bowl']\n# can you cut the bowls in half.\nsay('no, I can only move objects around')\nobjects = ['yellow block', 'green block', 'yellow bowl', 'gray block', 'gray bowl', 'green bowl']\n# stack the blocks on the right side with the gray one on the bottom.\nsay('Ok. stacking the blocks on the right side with the gray block on the bottom')\nright_side = parse_position('the right side')\nput_first_on_second('gray block', right_side)\norder_bottom_to_top = ['gray block', 'green block', 'yellow block']\nstack_objects_in_order(object_names=order_bottom_to_top)\nobjects = ['yellow block', 'green block', 'yellow bowl', 'blue block', 'blue bowl', 'green bowl']\n# hide the blue bowl.\nbowl_name = np.random.choice(['yellow bowl', 'green bowl'])\nsay(f'Sounds good! Hiding the blue bowl under the {bowl_name}')\nput_first_on_second(bowl_name, 'blue bowl')\nobjects = ['pink block', 'green block', 'pink bowl', 'blue block', 'blue bowl', 'green bowl']\n# stack everything with the green block on top.\nsay('Ok! Stacking everything with the green block on the top')\norder_bottom_to_top = ['blue bowl', 'pink bowl', 'green bowl', 'pink block', 'blue block', 'green block']\nstack_objects_in_order(object_names=order_bottom_to_top)\nobjects = ['pink block', 'green block', 'pink bowl', 'blue block', 'blue bowl', 'green bowl']\n# move the grass-colored bowl to the left.\nsay('Sure - moving the green bowl left by 10 centimeters')\nleft_pos = parse_position('a point 10cm left of the green bowl')\nput_first_on_second('green bowl', left_pos)\nobjects = ['pink block', 'green block', 'pink bowl', 'blue block', 'blue bowl', 'green bowl']\n# why did you move the red bowl.\nsay(f'I did not move the red bowl')\nobjects = ['pink block', 'green block', 'pink bowl', 'blue block', 'blue bowl', 'green bowl']\n# undo that.\nsay('Sure - moving the green bowl right by 10 centimeters')\nleft_pos = parse_position('a point 10cm right of the green bowl')\nput_first_on_second('green bowl', left_pos)\nobjects = ['brown bowl', 'green block', 'brown block', 'green bowl', 'blue bowl', 'blue block']\n# place the top most block to the corner closest to the bottom most block.\ntop_block_name = parse_obj_name('top most block', f'objects = {get_obj_names()}')\nbottom_block_name = parse_obj_name('bottom most block', f'objects = {get_obj_names()}')\nclosest_corner_pos = parse_position(f'the corner closest to the {bottom_block_name}', f'objects = {get_obj_names()}')\nsay(f'Putting the {top_block_name} on the {get_corner_name(closest_corner_pos)}')\nput_first_on_second(top_block_name, closest_corner_pos)\nobjects = ['brown bowl', 'green block', 'brown block', 'green bowl', 'blue bowl', 'blue block']\n# move the brown bowl to the side closest to the green block.\nclosest_side_position = parse_position('the side closest to the green block')\nsay(f'Got it - putting the brown bowl on the {get_side_name(closest_side_position)}')\nput_first_on_second('brown bowl', closest_side_position)\nobjects = ['brown bowl', 'green block', 'brown block', 'green bowl', 'blue bowl', 'blue block']\n# place the green block to the right of the bowl that has the blue block.\nbowl_name = parse_obj_name('the bowl that has the blue block', f'objects = {get_obj_names()}')\nif bowl_name:\n  target_pos = parse_position(f'a point 10cm to the right of the {bowl_name}')\n  say(f'No problem - placing the green block to the right of the {bowl_name}')\n  put_first_on_second('green block', target_pos)\nelse:\n  say('There are no bowls that has the blue block')\nobjects = ['brown bowl', 'green block', 'brown block', 'green bowl', 'blue bowl', 'blue block']\n# place the blue block in the empty bowl.\nempty_bowl_name = parse_obj_name('the empty bowl', f'objects = {get_obj_names()}')\nif empty_bowl_name:\n  say(f'Ok! Putting the blue block on the {empty_bowl_name}')\n  put_first_on_second('blue block', empty_bowl_name)\nelse:\n  say('There are no empty bowls')\nobjects = ['brown bowl', 'green block', 'brown block', 'green bowl', 'blue bowl', 'blue block']\n# move the other blocks to the bottom corners.\nblock_names = parse_obj_name('blocks other than the blue block', f'objects = {get_obj_names()}')\ncorners = parse_position('the bottom corners')\nfor block_name, pos in zip(block_names, corners):\n  put_first_on_second(block_name, pos)\nobjects = ['brown bowl', 'green block', 'brown block', 'green bowl', 'blue bowl', 'blue block']\n# move the red bowl a lot to the left of the blocks.\nsay('Sure! Moving the red bowl to a point left of the blocks')\nleft_pos = parse_position('a point 20cm left of the blocks')\nput_first_on_second('red bowl', left_pos)\nobjects = ['pink block', 'gray block', 'orange block']\n# move the pinkish colored block on the bottom side.\nsay('Ok - putting the pink block on the bottom side')\nbottom_side_pos = parse_position('the bottom side')\nput_first_on_second('pink block', bottom_side_pos)\nobjects = ['yellow bowl', 'blue block', 'yellow block', 'blue bowl']\n# is the blue block to the right of the yellow bowl?\nif parse_question('is the blue block to the right of the yellow bowl?', f'objects = {get_obj_names()}'):\n  say('yes, there is a blue block to the right of the yellow bow')\nelse:\n  say('no, there is\\'t a blue block to the right of the yellow bow')\nobjects = ['yellow bowl', 'blue block', 'yellow block', 'blue bowl']\n# how many yellow objects are there?\nn_yellow_objs = parse_question('how many yellow objects are there', f'objects = {get_obj_names()}')\nsay(f'there are {n_yellow_objs} yellow object')\nobjects = ['pink block', 'green block', 'pink bowl', 'blue block', 'blue bowl', 'green bowl']\n# move the left most block to the green bowl.\nleft_block_name = parse_obj_name('left most block', f'objects = {get_obj_names()}')\nsay(f'Moving the {left_block_name} on the green bowl')\nput_first_on_second(left_block_name, 'green bowl')\nobjects = ['pink block', 'green block', 'pink bowl', 'blue block', 'blue bowl', 'green bowl']\n# move the other blocks to different corners.\nblock_names = parse_obj_name(f'blocks other than the {left_block_name}', f'objects = {get_obj_names()}')\ncorners = parse_position('the corners')\nsay(f'Ok - moving the other {len(block_names)} blocks to different corners')\nfor block_name, pos in zip(block_names, corners):\n  put_first_on_second(block_name, pos)\nobjects = ['pink block', 'green block', 'pink bowl', 'blue block', 'blue bowl', 'green bowl']\n# is the pink block on the green bowl.\nif parse_question('is the pink block on the green bowl', f'objects = {get_obj_names()}'):\n  say('Yes - the pink block is on the green bowl.')\nelse:\n  say('No - the pink block is not on the green bowl.')\nobjects = ['pink block', 'green block', 'pink bowl', 'blue block', 'blue bowl', 'green bowl']\n# what are the blocks left of the green bowl.\nleft_block_names =  parse_question('what are the blocks left of the green bowl', f'objects = {get_obj_names()}')\nif len(left_block_names) > 0:\n  say(f'These blocks are left of the green bowl: {\", \".join(left_block_names)}')\nelse:\n  say('There are no blocks left of the green bowl')\nobjects = ['pink block', 'green block', 'pink bowl', 'blue block', 'blue bowl', 'green bowl']\n# if you see a purple bowl put it on the blue bowl\nif is_obj_visible('purple bowl'):\n  say('Putting the purple bowl on the pink bowl')\n  put_first_on_second('purple bowl', 'pink bowl')\nelse:\n  say('I don\\'t see a purple bowl')\nobjects = ['yellow block', 'green block', 'yellow bowl', 'blue block', 'blue bowl', 'green bowl']\n# imagine that the bowls are different biomes on earth and imagine that the blocks are parts of a building.\nsay('ok')\nobjects = ['yellow block', 'green block', 'yellow bowl', 'blue block', 'blue bowl', 'green bowl']\n# now build a tower in the grasslands.\norder_bottom_to_top = ['green bowl', 'blue block', 'green block', 'yellow block']\nsay('stacking the blocks on the green bowl')\nstack_objects_in_order(object_names=order_bottom_to_top)\nobjects = ['yellow block', 'green block', 'yellow bowl', 'gray block', 'gray bowl', 'green bowl']\n# show me what happens when the desert gets flooded by the ocean.\nsay('putting the yellow bowl on the blue bowl')\nput_first_on_second('yellow bowl', 'blue bowl')\nobjects = ['pink block', 'gray block', 'orange block']\n# move all blocks 5cm toward the top.\nsay('Ok - moving all blocks 5cm toward the top')\nblock_names = parse_obj_name('the blocks', f'objects = {get_obj_names()}')\nfor block_name in block_names:\n  target_pos = parse_position(f'a point 5cm above the {block_name}')\n  put_first_on_second(block_name, target_pos)\nobjects = ['cyan block', 'white block', 'purple bowl', 'blue block', 'blue bowl', 'white bowl']\n# make a triangle of blocks in the middle.\nblock_names = parse_obj_name('the blocks', f'objects = {get_obj_names()}')\ntriangle_pts = parse_position(f'a triangle with size 10cm around the middle with {len(block_names)} points')\nsay('Making a triangle of blocks around the middle of the workspace')\nfor block_name, pt in zip(block_names, triangle_pts):\n  put_first_on_second(block_name, pt)\nobjects = ['cyan block', 'white block', 'purple bowl', 'blue block', 'blue bowl', 'white bowl']\n# make the triangle smaller.\ntriangle_pts = transform_shape_pts('scale it by 0.5x', shape_pts=triangle_pts)\nsay('Making the triangle smaller')\nblock_names = parse_obj_name('the blocks', f'objects = {get_obj_names()}')\nfor block_name, pt in zip(block_names, triangle_pts):\n  put_first_on_second(block_name, pt)\nobjects = ['brown bowl', 'red block', 'brown block', 'red bowl', 'pink bowl', 'pink block']\n# put the red block on the farthest bowl.\nfarthest_bowl_name = parse_obj_name('the bowl farthest from the red block', f'objects = {get_obj_names()}')\nsay(f'Putting the red block on the {farthest_bowl_name}')\nput_first_on_second('red block', farthest_bowl_name)",
      "engine": "gpt-4",
      "max_tokens": 512,
      "temperature": 0,
      "query_prefix": "# ",
      "query_suffix": ".",
      "stop": [
        "#"
      ],
      "maintain_session": false,
      "debug_mode": false,
      "include_context": true,
      "has_return": true,
      "return_val_name": "new_shape_pts"
    },
    "transform_shape_pts": {
      "prompt_text": "import numpy as np\nfrom utils import get_obj_pos, get_obj_names, parse_position, parse_obj_name\n\n# make it bigger by 1.5.\nnew_shape_pts = scale_pts_around_centroid_np(shape_pts, scale_x=1.5, scale_y=1.5)\n# move it to the right by 10cm.\nnew_shape_pts = translate_pts_np(shape_pts, delta=[0.1, 0])\n# move it to the top by 20cm.\nnew_shape_pts = translate_pts_np(shape_pts, delta=[0, 0.2])\n# rotate it clockwise by 40 degrees.\nnew_shape_pts = rotate_pts_around_centroid_np(shape_pts, angle=-np.deg2rad(40))\n# rotate by 30 degrees and make it slightly smaller\nnew_shape_pts = rotate_pts_around_centroid_np(shape_pts, angle=np.deg2rad(30))\nnew_shape_pts = scale_pts_around_centroid_np(new_shape_pts, scale_x=0.7, scale_y=0.7)\n# move it toward the blue block.\nblock_name = parse_obj_name('the blue block', f'objects = {get_obj_names()}')\nblock_pos = get_obj_pos(block_name)\nmean_delta = np.mean(block_pos - shape_pts, axis=1)\nnew_shape_pts = translate_pts_np(shape_pts, mean_delta)",
      "engine": "gpt-4",
      "max_tokens": 512,
      "temperature": 0,
      "query_prefix": "# ",
      "query_suffix": ".",
      "stop": [
        "#"
      ],
      "maintain_session": false,
      "debug_mode": false,
      "include_context": true,
      "has_return": true,
      "return_val_name": "new_shape_pts"
    }
  }
}